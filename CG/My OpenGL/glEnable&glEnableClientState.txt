OpenGL是个状态机，我们通常见到的glEnable - glDisable函数就是通知OpenGL开启/关闭某种状态的，譬如光照、深度检测等等。但是也有glEnableClientState - glDisableClientState这对。它们的区别是通知的具体对象在概念上不一样――分别是服务端和客户端。事实上我也无法很清楚地告诉你区别之处，反正你把你电脑上的具体程序，包括它用到的内存等等看作客户端，把你电脑里面的――显卡里的OpenGL“模块”，乃至整张拥有OpenGL流水线、硬件实现OpenGL功能的显卡，作为服务端。它们各自维护一些“状态”，glEnable 等是直接维护流水线处理相关的状态的，glEnableClientState 维护的则是进入流水线前的状态。流水线早期的T&L阶段，程序的顶点数据就被获知而接受处理了。至于顶点是怎么来的――是glVertex来的，还是glDrawArray来的，流水线没必要知道――这就是客户端的任务，所以是否使用顶点数组（作为一种状态是否需要被启动）都是由客户端决定。显示列表的glCallList比较特殊，它绕过客户端，直接通知服务端把之前初始化时设定的代码段所映射的硬件设置“启亮”，这是相当于直接把显存的某一段占有而随时呼唤了，硬件对此命令没有丝毫犹豫地接受，对该呼唤的答应变成一种“神经反射”行为――这是最理想最高级的“绘制”。